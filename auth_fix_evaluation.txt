## Evaluaci√≥n del Problema y Propuesta de Soluci√≥n para el Error de Autenticaci√≥n

**Problema Identificado:**
El proyecto "Idea Saver" presenta una cascada de problemas interconectados relacionados con la autenticaci√≥n y la gesti√≥n del perfil de usuario, que culminan en un bucle de redirecci√≥n post-login y el error "Rendered fewer hooks than expected".

**An√°lisis de las Causas Ra√≠z:**
1.  **Condici√≥n de Carrera en la Sincronizaci√≥n de Estado (`Rendered fewer hooks than expected`):** El `useEffect` en `src/hooks/use-auth.tsx` que escucha los cambios de estado de autenticaci√≥n (`onAuthStateChange`) actualiza los estados `user` y `profile` de forma as√≠ncrona. Esto, combinado con la l√≥gica de renderizado condicional en las p√°ginas (`/login`, `/record`), provoca que React vea un n√∫mero inconsistente de Hooks llamados durante los renders r√°pidos, especialmente cuando `isLoading` cambia o el `profile` a√∫n no se ha cargado.
2.  **Fallo en Creaci√≥n/Carga de Perfil (RLS Violation):** Los logs de Supabase indican errores de Row-Level Security (RLS) al intentar hacer `upsert` del perfil. Esto sugiere que `auth.uid()` podr√≠a no estar disponible o ser `NULL` en el contexto del cliente justo despu√©s de la autenticaci√≥n, impidiendo que la pol√≠tica RLS valide la inserci√≥n del perfil. Si el perfil no se carga, la aplicaci√≥n permanece en un estado inconsistente, exacerbando el problema de los Hooks.
3.  **Bucle de Redirecci√≥n:** Es un s√≠ntoma de los dos problemas anteriores. `useAuth` intenta redirigir a `/record` al detectar un usuario, pero si `/record` no puede cargar el perfil o entra en un estado de carga prolongado, su propia l√≥gica defensiva redirige de nuevo a `/login`, creando un ciclo.

**Propuesta de Soluci√≥n (Fase 1: Estabilizaci√≥n de Hooks y Carga):**
La soluci√≥n inicial se centra en estabilizar la gesti√≥n del estado en `src/hooks/use-auth.tsx` para mitigar la condici√≥n de carrera y el error de los Hooks. Esto se lograr√° mediante:

1.  **Uso de `isMounted`:** Introducir una bandera `isMounted` dentro del `useEffect` para asegurar que las actualizaciones de estado (`setUser`, `setProfile`, `setIsLoading`) solo ocurran si el componente `AuthProvider` a√∫n est√° montado. Esto previene errores cuando el componente se desmonta antes de que las operaciones as√≠ncronas (`onAuthStateChange`, `upsert`) se completen.
2.  **Gesti√≥n Consistente de `isLoading`:**
    *   `setIsLoading(true)` al inicio de cada procesamiento de cambio de estado de autenticaci√≥n dentro de `onAuthStateChange`. Esto asegura que la UI refleje un estado de carga mientras se resuelven `user` y `profile`.
    *   `setIsLoading(false)` solo despu√©s de que todas las operaciones as√≠ncronas (obtenci√≥n de `user` y `profile` o determinaci√≥n de su ausencia) hayan finalizado y los estados correspondientes se hayan establecido. Esto garantiza que `isLoading` sea `false` solo cuando el estado de autenticaci√≥n y perfil es definitivo para ese render.
3.  **Revisi√≥n de la L√≥gica de `upsert`:** Aunque la soluci√≥n principal se enfoca en los Hooks, la revisi√≥n del `upsert` de perfil dentro de `onAuthStateChange` es crucial. La implementaci√≥n actual ya intenta un `upsert` con `onConflict: 'id'`, lo cual es correcto. El problema de RLS probablemente requiere una revisi√≥n de las pol√≠ticas de Supabase o una estrategia de creaci√≥n de perfil m√°s robusta (posiblemente en una funci√≥n de Supabase o un webhook) si el `auth.uid()` no es fiable en el cliente en el momento del `upsert`.

**Cambios Espec√≠ficos en `src/hooks/use-auth.tsx`:**
Se modificar√° el `useEffect` principal para incluir la l√≥gica de `isMounted` y la gesti√≥n de `isLoading` de la siguiente manera:

```typescript
  useEffect(() => {
    const supabase = getSupabaseBrowserClient();
    let isMounted = true; // Flag to prevent state updates on unmounted component

    const { data: authListener } = supabase.auth.onAuthStateChange(async (event, session) => {
      if (!isMounted) return; // Prevent state updates if component unmounted

      console.log('üîê useAuth: Auth State Change Event:', event, 'Session User ID:', session?.user?.id || 'none');
      setIsLoading(true); // Set loading at the start of any auth state change processing

      if (session?.user) {
        console.log('‚úÖ useAuth: User detected, fetching profile for ID:', session.user.id, 'Email:', session.user.email);
        setUser(session.user); // Set user immediately

        const { data: profileData, error: profileUpsertError } = await supabase
          .from('profiles')
          .upsert({
            id: session.user.id,
            email: session.user.email,
            credits: 25, 
            current_plan: 'free',
            has_purchased_app: false,
            cloud_sync_enabled: false,
            auto_cloud_sync: false,
            deletion_policy_days: 0,
            created_at: new Date().toISOString()
          }, { onConflict: 'id' })
          .select('*')
          .single();

        if (!isMounted) return; // Check again after async operation

        if (profileUpsertError) {
          console.error('‚ùå useAuth: Error upserting user profile:', profileUpsertError);
          setProfile(null);
        } else {
          console.log('‚úÖ useAuth: Profile upserted/fetched successfully:', profileData?.id, 'Credits:', profileData?.credits);
          setProfile(profileData as UserProfile);
        }
      } else {
        console.log('üö™ useAuth: No user detected (logged out or initial load)');
        setUser(null);
        setProfile(null);
      }

      if (isMounted) {
        setIsLoading(false); // Set loading to false only after all state is resolved
        console.log('üîÑ useAuth: Auth state processed. isLoading set to false.');
      }
    });

    console.log('üîç useAuth: onAuthStateChange listener initialized.');

    return () => {
      isMounted = false; // Cleanup for unmounted component
      if (authListener && authListener.subscription) {
        authListener.subscription.unsubscribe();
      }
    };
  }, []); // Dependency array is empty: this useEffect runs once on mount.
```

**Pr√≥ximos Pasos:**
Una vez que se apliquen estos cambios, se deber√° probar el flujo de login y la navegaci√≥n para verificar si el bucle de redirecci√≥n y el error de Hooks se han resuelto. Si el problema de RLS persiste, se requerir√° una investigaci√≥n m√°s profunda de las pol√≠ticas de Supabase y/o la implementaci√≥n de la creaci√≥n de perfiles.